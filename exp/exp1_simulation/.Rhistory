data_dir <- "nhanes_data"
if (!dir.exists(data_dir)) dir.create(data_dir)
# ‚úÖ Step 3: Delete & Re-Download Corrupt `.XPT` Files
invisible(mapply(download_nhanes_data, names(nhanes_urls), nhanes_urls))
# Load necessary libraries
library(httr)
library(tidyverse)
library(janitor)
library(fastDummies)
install.packages("foreign")  # Install foreign package if not already installed
library(foreign)
# ‚úÖ Step 1: Verify NHANES Dataset URLs (Manually Check!)
nhanes_urls <- list(
"DEMO" = "https://wwwn.cdc.gov/Nchs/Nhanes/2017-2018/DEMO.XPT",
"BMX_J" = "https://wwwn.cdc.gov/Nchs/Nhanes/2017-2018/BMX_J.XPT",
"BPX_J" = "https://wwwn.cdc.gov/Nchs/Nhanes/2017-2018/BPX_J.XPT",
"DIQ_J" = "https://wwwn.cdc.gov/Nchs/Nhanes/2017-2018/DIQ_J.XPT",
"HDL_J" = "https://wwwn.cdc.gov/Nchs/Nhanes/2017-2018/HDL_J.XPT",
"TRIGLY_J" = "https://wwwn.cdc.gov/Nchs/Nhanes/2017-2018/TRIGLY_J.XPT"
# üîπ Add more datasets manually after verifying URLs
)
# ‚úÖ Step 2: Set Up Download Directory
data_dir <- "nhanes_data"
if (!dir.exists(data_dir)) dir.create(data_dir)
# ‚úÖ Step 3: Delete & Re-Download Corrupt `.XPT` Files
invisible(mapply(download_nhanes_data, names(nhanes_urls), nhanes_urls))
# Load necessary libraries
library(tidyverse)
library(haven)
library(janitor)
library(fastDummies)
library(foreign)
library(data.table)  # Faster merging
# ‚úÖ Step 1: Define NHANES Data Directory
data_dir <- "nhanes_data"
# ‚úÖ Step 2: Verify `.XPT` Files and Fix Case Sensitivity
xpt_files <- list.files(data_dir, pattern = "\\.XPT$", full.names = TRUE)
# If no `.XPT` files found, check for lowercase `.xpt`
if (length(xpt_files) == 0) {
xpt_files_lower <- list.files(data_dir, pattern = "\\.xpt$", full.names = TRUE)
if (length(xpt_files_lower) > 0) {
message("üîÑ Fixing lowercase `.xpt` file extensions...")
# Rename `.xpt` files to `.XPT`
file.rename(
from = xpt_files_lower,
to = gsub("\\.xpt$", ".XPT", xpt_files_lower)
)
# Recheck files
xpt_files <- list.files(data_dir, pattern = "\\.XPT$", full.names = TRUE)
}
}
# If still no `.XPT` files, check for incorrect path
if (length(xpt_files) == 0) {
stop("‚ùå No `.XPT` files found. Verify the `nhanes_data/` folder location and file extensions.")
}
# ‚úÖ Step 3: Read `.XPT` Files Using `foreign::read.xport()`
read_nhanes_data <- function(file) {
tryCatch({
df <- as.data.table(read.xport(file)) %>%
clean_names()
# Check if `seqn` column exists, otherwise remove the dataset
if (!"seqn" %in% colnames(df)) {
message("‚ö†Ô∏è Skipping file (no `seqn` column):", file)
return(NULL)
}
# Remove dataset_name column to prevent duplicates
df[, dataset_name := NULL]
return(df)
}, error = function(e) {
message("‚ùå Failed to read:", file)
return(NULL)
})
}
# Read all datasets
nhanes_list <- lapply(xpt_files, read_nhanes_data)
nhanes_list <- nhanes_list[!sapply(nhanes_list, is.null)]  # Remove NULL datasets
if (length(nhanes_list) == 0) stop("‚ùå No valid datasets with `seqn` were read.")
# Optimal Sampling Simulation
# Match Dataset to Pairs
# Parallel preparation
library(doParallel)
library(doParallel)
# Optimal Sampling Simulation
# Match Dataset to Pairs
# Parallel preparation
library(doParallel)
library(foreach)
# Set the number of cores to use
#num_cores <- as.numeric(Sys.getenv("SLURM_CPUS_PER_TASK"))
num_cores <- 2
# Initialize a parallel backend
cl <- makeCluster(num_cores)
registerDoParallel(cl)
# package preparation
library(MatchIt)
# set seeds
set.seed(2024)
# (full) matching function
data_matched_pair <- function(X, Z, Y) {
# arguments:
# X: covariates
# Z: treatment assignment
# Y: outcomes
# return:
# data_pair_diff: dataset of outcomes into matched pairs
# match dataset in pairs
data_full_match = data.frame(cbind(X, Z))
data_full_outcomes = Y
# full matching on pretreatment variables
full_match <- matchit(Z ~ ., data = data_full_match, method = "full")
# convert matching results into pair-matched-difference dataset
for (class in 1:length(full_match$subclass)) {
class_indices = which(full_match$subclass == class)
treat_indices = c()
control_indices = c()
for (index in class_indices) {
if (data_full_match$Z[index] == 1){
treat_indices = append(treat_indices, index)
}else {
control_indices = append(control_indices, index)
}
}
data_pair_subclass_diff = data.frame((matrix(ncol = ncol(data_full_outcomes),
nrow = length(treat_indices) * length(control_indices) )))
data_pair_subclass_control = data.frame((matrix(ncol = ncol(data_full_outcomes),
nrow = length(treat_indices) * length(control_indices) )))
data_pair_subclass_treat = data.frame((matrix(ncol = ncol(data_full_outcomes),
nrow = length(treat_indices) * length(control_indices) )))
k = 1
for (i in treat_indices) {
for (j in control_indices) {
data_pair_subclass_diff[k, ] = data_full_outcomes[i, ]-data_full_outcomes[j, ]
data_pair_subclass_control[k, ] = data_full_outcomes[j, ]
data_pair_subclass_treat[k, ] = data_full_outcomes[i, ]
k = k+1
}
}
if (class == 1) {
data_pair_diff = data_pair_subclass_diff
data_pair_control = data_pair_subclass_control
data_pair_treat = data_pair_subclass_treat
} else {
data_pair_diff = rbind(data_pair_diff, data_pair_subclass_diff)
data_pair_control = rbind(data_pair_control, data_pair_subclass_control)
data_pair_treat = rbind(data_pair_treat, data_pair_subclass_treat)
}
}
colnames(data_pair_diff) = colnames(Y)
colnames(data_pair_control) = colnames(Y)
colnames(data_pair_treat) = colnames(Y)
return_list = list(data_pair_diff = data_pair_diff, data_pair_control = data_pair_control, data_pair_treat = data_pair_treat)
return(return_list)
}
# match dataset into pairs
D = 5 # number of covariates
K_vec = c(10, 100, 500, 1000) # number of outcomes
Gamma_vec = c(1, 1.25, 1.5, 1.75, 2) # design sensitivity
for(i1 in 1:length(K_vec)) {
K = K_vec[i1]
for(i2 in 1:length(Gamma_vec)) {
Gamma = Gamma_vec[i2]
# read data
data_name = paste(c(paste(c("data", "whole", "outcome", K, "Gamma", Gamma), collapse="_"), "csv"), collapse=".")
data_path = paste(c(paste(c(current_dir, "data_whole"), collapse="/"), data_name), collapse="/")
data_generate_full = read.csv(data_path)
# name variables
X_name_list = NULL
Y_c_name_list = NULL
Y_t_name_list = NULL
Y_name_list = NULL
for (i in 1:D) {
X_var_name = paste0("X", i)
X_name_list = c(X_name_list, X_var_name)
}
for (j in 1:K) {
Y_c_var_name = paste0("Yc", j)
Y_t_var_name = paste0("Yt", j)
Y_var_name = paste0("Y", j)
Y_c_name_list = c(Y_c_name_list, Y_c_var_name)
Y_t_name_list = c(Y_t_name_list, Y_t_var_name)
Y_name_list = c(Y_name_list, Y_var_name)
}
# initialize variables
Z = data_generate_full[, "Z"]
X = data_generate_full[, X_name_list]
U = data_generate_full[, "U"]
Y_c = data_generate_full[, Y_c_name_list]
Y_t = data_generate_full[, Y_t_name_list]
Y = data_generate_full[, Y_name_list]
# match dataset into pairs by function
data_pair_diff = data_matched_pair(X, Z, Y)$data_pair_diff
data_pair_control = data_matched_pair(X, Z, Y)$data_pair_control
data_pair_treat = data_matched_pair(X, Z, Y)$data_pair_treat
# save dataset to csv
file_name_diff = paste(c(paste(c("data", "match_diff", "outcome", K, "Gamma", Gamma), collapse="_"), "csv"), collapse=".")
file_name_control = paste(c(paste(c("data", "match_control", "outcome", K, "Gamma", Gamma), collapse="_"), "csv"), collapse=".")
file_name_treat = paste(c(paste(c("data", "match_treat", "outcome", K, "Gamma", Gamma), collapse="_"), "csv"), collapse=".")
file_path_diff = paste(c(paste(c(current_dir, "data_pair"), collapse="/"), file_name_diff), collapse="/")
file_path_control = paste(c(paste(c(current_dir, "data_pair"), collapse="/"), file_name_control), collapse="/")
file_path_treat = paste(c(paste(c(current_dir, "data_pair"), collapse="/"), file_name_treat), collapse="/")
write.csv(data_pair_diff, file_path_diff, row.names = FALSE) # only need to save the dataset once
write.csv(data_pair_control, file_path_control, row.names = FALSE) # only need to save the dataset once
write.csv(data_pair_treat, file_path_treat, row.names = FALSE) # only need to save the dataset once
print(paste("K =", K, "; Gamma =", Gamma, ";"))
}
}
# Optimal Sampling Simulation
# Match Dataset to Pairs
# Parallel preparation
library(doParallel)
library(foreach)
# Set the number of cores to use
#num_cores <- as.numeric(Sys.getenv("SLURM_CPUS_PER_TASK"))
num_cores <- 2
# Initialize a parallel backend
cl <- makeCluster(num_cores)
registerDoParallel(cl)
# package preparation
library(MatchIt)
# set relative path
current_dir = getwd()
parent_dir = dirname(getwd())
# set seeds
set.seed(2024)
# (full) matching function
data_matched_pair <- function(X, Z, Y) {
# arguments:
# X: covariates
# Z: treatment assignment
# Y: outcomes
# return:
# data_pair_diff: dataset of outcomes into matched pairs
# match dataset in pairs
data_full_match = data.frame(cbind(X, Z))
data_full_outcomes = Y
# full matching on pretreatment variables
full_match <- matchit(Z ~ ., data = data_full_match, method = "full")
# convert matching results into pair-matched-difference dataset
for (class in 1:length(full_match$subclass)) {
class_indices = which(full_match$subclass == class)
treat_indices = c()
control_indices = c()
for (index in class_indices) {
if (data_full_match$Z[index] == 1){
treat_indices = append(treat_indices, index)
}else {
control_indices = append(control_indices, index)
}
}
data_pair_subclass_diff = data.frame((matrix(ncol = ncol(data_full_outcomes),
nrow = length(treat_indices) * length(control_indices) )))
data_pair_subclass_control = data.frame((matrix(ncol = ncol(data_full_outcomes),
nrow = length(treat_indices) * length(control_indices) )))
data_pair_subclass_treat = data.frame((matrix(ncol = ncol(data_full_outcomes),
nrow = length(treat_indices) * length(control_indices) )))
k = 1
for (i in treat_indices) {
for (j in control_indices) {
data_pair_subclass_diff[k, ] = data_full_outcomes[i, ]-data_full_outcomes[j, ]
data_pair_subclass_control[k, ] = data_full_outcomes[j, ]
data_pair_subclass_treat[k, ] = data_full_outcomes[i, ]
k = k+1
}
}
if (class == 1) {
data_pair_diff = data_pair_subclass_diff
data_pair_control = data_pair_subclass_control
data_pair_treat = data_pair_subclass_treat
} else {
data_pair_diff = rbind(data_pair_diff, data_pair_subclass_diff)
data_pair_control = rbind(data_pair_control, data_pair_subclass_control)
data_pair_treat = rbind(data_pair_treat, data_pair_subclass_treat)
}
}
colnames(data_pair_diff) = colnames(Y)
colnames(data_pair_control) = colnames(Y)
colnames(data_pair_treat) = colnames(Y)
return_list = list(data_pair_diff = data_pair_diff, data_pair_control = data_pair_control, data_pair_treat = data_pair_treat)
return(return_list)
}
# match dataset into pairs
D = 5 # number of covariates
K_vec = c(10, 100, 500, 1000) # number of outcomes
Gamma_vec = c(1, 1.25, 1.5, 1.75, 2) # design sensitivity
for(i1 in 1:length(K_vec)) {
K = K_vec[i1]
for(i2 in 1:length(Gamma_vec)) {
Gamma = Gamma_vec[i2]
# read data
data_name = paste(c(paste(c("data", "whole", "outcome", K, "Gamma", Gamma), collapse="_"), "csv"), collapse=".")
data_path = paste(c(paste(c(current_dir, "data_whole"), collapse="/"), data_name), collapse="/")
data_generate_full = read.csv(data_path)
# name variables
X_name_list = NULL
Y_c_name_list = NULL
Y_t_name_list = NULL
Y_name_list = NULL
for (i in 1:D) {
X_var_name = paste0("X", i)
X_name_list = c(X_name_list, X_var_name)
}
for (j in 1:K) {
Y_c_var_name = paste0("Yc", j)
Y_t_var_name = paste0("Yt", j)
Y_var_name = paste0("Y", j)
Y_c_name_list = c(Y_c_name_list, Y_c_var_name)
Y_t_name_list = c(Y_t_name_list, Y_t_var_name)
Y_name_list = c(Y_name_list, Y_var_name)
}
# initialize variables
Z = data_generate_full[, "Z"]
X = data_generate_full[, X_name_list]
U = data_generate_full[, "U"]
Y_c = data_generate_full[, Y_c_name_list]
Y_t = data_generate_full[, Y_t_name_list]
Y = data_generate_full[, Y_name_list]
# match dataset into pairs by function
data_pair_diff = data_matched_pair(X, Z, Y)$data_pair_diff
data_pair_control = data_matched_pair(X, Z, Y)$data_pair_control
data_pair_treat = data_matched_pair(X, Z, Y)$data_pair_treat
# save dataset to csv
file_name_diff = paste(c(paste(c("data", "match_diff", "outcome", K, "Gamma", Gamma), collapse="_"), "csv"), collapse=".")
file_name_control = paste(c(paste(c("data", "match_control", "outcome", K, "Gamma", Gamma), collapse="_"), "csv"), collapse=".")
file_name_treat = paste(c(paste(c("data", "match_treat", "outcome", K, "Gamma", Gamma), collapse="_"), "csv"), collapse=".")
file_path_diff = paste(c(paste(c(current_dir, "data_pair"), collapse="/"), file_name_diff), collapse="/")
file_path_control = paste(c(paste(c(current_dir, "data_pair"), collapse="/"), file_name_control), collapse="/")
file_path_treat = paste(c(paste(c(current_dir, "data_pair"), collapse="/"), file_name_treat), collapse="/")
write.csv(data_pair_diff, file_path_diff, row.names = FALSE) # only need to save the dataset once
write.csv(data_pair_control, file_path_control, row.names = FALSE) # only need to save the dataset once
write.csv(data_pair_treat, file_path_treat, row.names = FALSE) # only need to save the dataset once
print(paste("K =", K, "; Gamma =", Gamma, ";"))
}
}
# Optimal Sampling
# Example Power Plot
# Load necessary library
library(ggplot2)
# Set relative path
current_dir <- getwd()
# Load dataset
data_power <- read.csv(paste(c(current_dir, "evaluation_result/power_outcome_10_I_200_method_select.csv"), collapse="/"))
setwd("/Users/Qishuo/Code/Optimal_Sampling/exp/exp1_simulation")
# Optimal Sampling
# Example Power Plot
# Load necessary library
library(ggplot2)
# Set relative path
current_dir <- getwd()
# Load dataset
data_power <- read.csv(paste(c(current_dir, "evaluation_result/power_outcome_10_I_200_method_select.csv"), collapse="/"))
# Read the dataset without header
df <- read.csv(file_path, header = FALSE)
# Optimal Sampling
# Example Power Plot
# Load necessary library
library(ggplot2)
# Set relative path
current_dir <- getwd()
# Load dataset
data_dir <- paste(c(current_dir, "evaluation_result/power_outcome_10_I_200_method_select.csv"), collapse="/")
# Read the dataset without header
df <- read.csv(data_dir, header = FALSE)
# Extract the first row
row1 <- df[1, ]
# Convert to a dataframe for plotting
row1_df <- data.frame(Index = seq_along(row1), Value = as.numeric(row1))
# Create the plot
ggplot(row1_df, aes(x = Index, y = Value)) +
geom_bar(stat = "identity", fill = "blue") +
theme_minimal() +
labs(title = "Plot of 1st Row Values",
x = "Index",
y = "Values") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
View(df)
# Optimal Sampling
# Example Power Plot
# Load necessary library
library(ggplot2)
# Set relative path
current_dir <- getwd()
# Load dataset
data_dir <- paste(c(current_dir, "evaluation_result/power_outcome_10_I_200_method_select.csv"), collapse="/")
# Read the dataset without header
df <- read.csv(data_dir, header = FALSE, stringsAsFactors = FALSE)
# Extract the first row
row1 <- df[1, ]
# Convert to a dataframe for plotting
row1_df <- data.frame(Index = seq_along(row1), Value = as.numeric(row1))
# Create the plot
ggplot(row1_df, aes(x = Index, y = Value)) +
geom_bar(stat = "identity", fill = "blue") +
theme_minimal() +
labs(title = "Plot of 1st Row Values",
x = "Index",
y = "Values") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
View(df)
# Optimal Sampling
# Example Power Plot
# Load necessary library
library(ggplot2)
# Set relative path
current_dir <- getwd()
# Load dataset
data_dir <- paste(c(current_dir, "evaluation_result/power_outcome_10_I_200_method_select.csv"), collapse="/")
# Read the dataset without header
df <- read.csv(data_dir, header = FALSE, stringsAsFactors = FALSE)[2:, ]
View(df)
# Optimal Sampling
# Example Power Plot
# Load necessary library
library(ggplot2)
# Set relative path
current_dir <- getwd()
# Load dataset
data_dir <- paste(c(current_dir, "evaluation_result/power_outcome_10_I_200_method_select.csv"), collapse="/")
# Read the dataset without header
df <- read.csv(data_dir, header = FALSE, stringsAsFactors = FALSE)
# Extract the first row
row1 <- df[2, ]
# Convert to a dataframe for plotting
row1_df <- data.frame(Index = seq_along(row1), Value = as.numeric(row1))
# Create the plot
ggplot(row1_df, aes(x = Index, y = Value)) +
geom_bar(stat = "identity", fill = "blue") +
theme_minimal() +
labs(title = "Plot of 1st Row Values",
x = "Index",
y = "Values") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Optimal Sampling
# Example Power Plot
# Load necessary library
library(ggplot2)
# Set relative path
current_dir <- getwd()
# Load dataset
data_dir <- file.path(current_dir, "evaluation_result", "power_outcome_10_I_200_method_select.csv")
# Read the dataset without header
df <- read.csv(data_dir, header = FALSE, stringsAsFactors = FALSE)
# Extract the first row and convert it to numeric (handling possible non-numeric values)
row1 <- as.numeric(as.character(unlist(df[1, ])))
# Remove NA values (caused by non-numeric entries)
row1 <- row1[!is.na(row1)]
# Convert to a dataframe for plotting
row1_df <- data.frame(SplitFraction = seq_along(row1), TestPower = row1)
# Create the plot
p <- ggplot(row1_df, aes(x = SplitFraction, y = TestPower)) +
geom_line(color = "blue", size = 1) +  # Line plot instead of bar
geom_point(color = "red", size = 2) +  # Optional: add points for clarity
theme_minimal() +
labs(x = "Split fraction", y = "Test power")  # No title
# Save the plot in the same directory as the R script
save_path <- file.path(current_dir, "example_power_plot_outcome_10_I_200_method_select.png")
ggsave(save_path, plot = p, width = 6, height = 4, dpi = 300)
# Print save path for confirmation
print(paste("Plot saved at:", save_path))
# Optimal Sampling
# Example Power Plot
# Load necessary library
library(ggplot2)
# Set relative path
current_dir <- getwd()
# Load dataset
data_dir <- file.path(current_dir, "evaluation_result", "power_outcome_10_I_200_method_select.csv")
# Read the dataset without header
df <- read.csv(data_dir, header = FALSE, stringsAsFactors = FALSE)
# Extract the first row and convert it to numeric (handling possible non-numeric values)
row1 <- as.numeric(as.character(unlist(df[2, ])))
# Remove NA values (caused by non-numeric entries)
row1 <- row1[!is.na(row1)]
# Convert to a dataframe for plotting
row1_df <- data.frame(SplitFraction = seq_along(row1), TestPower = row1)
# Create the plot
p <- ggplot(row1_df, aes(x = SplitFraction, y = TestPower)) +
geom_line(color = "blue", size = 1) +  # Line plot instead of bar
geom_point(color = "red", size = 2) +  # Optional: add points for clarity
theme_minimal() +
labs(x = "Split fraction", y = "Test power")  # No title
# Save the plot in the same directory as the R script
save_path <- file.path(current_dir, "example_power_plot_outcome_10_I_200_method_select.png")
ggsave(save_path, plot = p, width = 6, height = 4, dpi = 300)
# Print save path for confirmation
print(paste("Plot saved at:", save_path))
# Optimal Sampling
# Example Power Plot
# Load necessary library
library(ggplot2)
# Set relative path
current_dir <- getwd()
# Load dataset
data_dir <- file.path(current_dir, "evaluation_result", "power_outcome_10_I_200_method_select.csv")
# Read the dataset without header
df <- read.csv(data_dir, header = FALSE, stringsAsFactors = FALSE)
# Extract the second row (since the first row contains column names)
row2 <- as.numeric(as.character(unlist(df[2, ])))
# Remove NA values (caused by non-numeric entries)
row2 <- row2[!is.na(row2)]
# Convert to a dataframe for plotting
row2_df <- data.frame(SplitFraction = seq_along(row2), TestPower = row2)
# Create the plot
p <- ggplot(row2_df, aes(x = SplitFraction, y = TestPower)) +
geom_line(color = "blue", size = 1) +  # Line plot
geom_point(color = "red", size = 2) +  # Points for clarity
theme_classic() +  # Removes grey background
labs(x = "Split fraction", y = "Test power")  # No title
# Save the plot in the same directory as the R script
save_path <- file.path(current_dir, "example_power_plot_outcome_10_I_200_method_select.png")
ggsave(save_path, plot = p, width = 6, height = 4, dpi = 300)
# Print save path for confirmation
print(paste("Plot saved at:", save_path))
